
param iA, iB, iC.

set interactiveMode = true.

type key[ large, fixed].
type hashoutput1[large, fixed].
type tdi_t[bounded].
type smr_t[bounded].

channel start, end, c1, c2, c3, c4, c5, c6.


expand ROM_hash_large(
    key,                 (**)
    bitstring,         (*hashinput is the type of the input of the hash function.*)
    hashoutput1,        (*hashoutput is the type of the output of the hash function, 
                                    must be bounded or nonuniform (typically fixed)*)
                                (*如果这里这里说了fixed，那么我们还可以用bitstring吗?还是定义一个type*)    
    hash1,               (*hash (key ,hashinput ) : hashoutput is the hash function.*)
    hashoracle1,  (*hashoracle is a process that allows the adversary to call the hash function*)
    qH1                      (*qH is the number of queries to the hash oracle*)
).

(*
insert 10 "let tdi_t2bitstring(x11)=x1 in"

*)


fun get_tdi():tdi_t.
fun smr_f(tdi_t, hashoutput1):smr_t[data].
fun tdi_t2bitstring(tdi_t):bitstring[data].

event test1(tdi_t).
event test2(tdi_t).
query x:tdi_t;
    event(test2(x)) ==>event(test1(x)).



let A(hk_A:key,mk_A:key)=
    in(c1, ());
    let tdi=get_tdi() in
    let tdih_A:hashoutput1=hash1(hk_A, tdi_t2bitstring(tdi)) in
    let smr_A:smr_t=smr_f(tdi,tdih_A) in
    event test1(tdi);
    out(c2, (smr_A)).


let B(hk_B:key,mk_B:key)=
    in(c3, (smr:smr_t));
    let smr_f(tdi, tdih)=smr in
    find i<=iA suchthat defined (tdih_A[i]) && tdih=tdih_A[i] then
    if(hash1(hk_B, tdi_t2bitstring(tdi) )=tdih) then
        event test2(tdi);
        out(c4, ()).

process
    in(start, ());
    new hk:key;
    new mk:key;
    out(end, ());
    (hashoracle1(hk)|
    !i<=iA A(hk,mk)|
    !i<=iB B(hk,mk))
