(*
    TDX protocol
    six entities: Challenger, CPU, TDXM, TD, VMM, QE.
    Steps:
    1. Challenger->TD: Attestation requirements
    2. TD generate rdata and TD->TDXM: request TD report
    3.  Assemble tdi from TDCS and compute its hash tdih
    4. TDXM->CPU: rtyp, tdi, rdata and request SEAMREPORT
    5. CPU genarate SEAMREPORT
    6. CPU->TDXM: SEAMREPORT
    7. TDXM create TDREPORT
    8. TDXM->TD: TDREPORT
    9. TD->VMM: TDREPORT and request Quote
    10. VMM->QE: TDREPORT
    11. QE check hashes
    12. QE ->CPU: report mac struct
    13. CPU verify the MAC in the report
    14. CPU->QE: Verification result
    15. QE sign to form Quote
    16. QE->VMM: Quote
    17. VMM->TD: TD: Quote
    18. TD->Challenger: Quote
*)

(*replication numbers*)
param qChallenger, qTD, qTDXM, qCPU, qQE, qVMM.

(*
    bounded means that the type is a set of bitstrings of bounded length or perhaps ⊥. In other
        words, the type is a finite subset of bitstrings plus ⊥.
    fixed means that the type is the set of all bitstrings of a certain length n. In particular, the
        type is a finite set, so fixed implies bounded.
    large: By default, large means that the type T is large enough so that all collisions with ran-
        dom elements of T can be eliminated
*)
(*These three types are used in the macro IND_CCA2_public_key_enc and UF_CMA_det_signature*)
type keyseed [large, bounded].
type skey [bounded].
type pkey [bounded].

(*channel name*)
channel c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, start.

type key [large,fixed].
type hashoutput [large, fixed].

expand ROM_hash_large(
    key,                 (**)
    bitstring,         (*hashinput is the type of the input of the hash function.*)
    hashoutput,        (*hashoutput is the type of the output of the hash function, 
                                    must be bounded or nonuniform (typically fixed)*)
                                (*如果这里这里说了fixed，那么我们还可以用bitstring吗?还是定义一个type*)    
    hash,               (*hash (key ,hashinput ) : hashoutput is the hash function.*)
    hashoracle,  (*hashoracle is a process that allows the adversary to call the hash function*)
    qH                      (*qH is the number of queries to the hash oracle*)
).

(* MAC *)
proba Pmac.
expand SUF_CMA_det_mac(
    key,            (*mkey is the type of keys, must be bounded*)
    bitstring , (*macinput is the type of inputs of MACs*)
    bitstring,  (*macres is the type of MACs.*)
    mac,          (*mac(macinput ,mkey ) : macres is the MAC function.*)
    check,      (*check (macinput ,mkey ,macres ) : bool is the verification function*)
    Pmac        (*Pmac(t,N,N′,Nu′,l) is the probability of breaking the SUF-CMA property in time t for one key,
                            N MAC queries, N′ verification queries modified by the transformation and Nu verification queries
                            left unchanged by the transformation for messages of length at most l.*)
).

(* Signature *)
proba Psign.
proba Psigncoll.
expand UF_CMA_det_signature(
        keyseed,
        pkey,                  (*pkey is the type of public keys, must be bounded.*)
        skey,                  (*skey is the type of secret keys, must be bounded.*)
        bitstring,            (*signinput*)
        bitstring,            (*signature*)
       	sskgen,                  (*skgen(keyseed ) : skey is the secret key generation function.*)
        spkgen,                 (*pkgen (keyseed ) : pkey is the public key generation function.*)
        sign,                     (*sign (signinput ,skey ) : signature is the signature function.*)
        verify,                  (*check (signinput ,pkey ,signature) : bool is the verification function.*)
        Psign,                  (*Psign (t,N,l) is the probability of breaking the UF-CMA property 
                                        in time t, for one key, N signature queries with messages of length at most l.*)
        Psigncoll           (*Psigncoll is the probability of collision between independently generated keys.*)
).

(* Asymmetric encryption *)
proba Penc.
proba Penccoll.
expand IND_CCA2_public_key_enc(
        keyseed, 
        pkey,                       (*pkey is the type of public keys, must be bounded*)
        skey,                        (*skey is the type of secret keys, must be bounded*) 
        bitstring,                (*cleartext is the type of cleartexts.*)
        bitstring,             (*ciphertext is the type of ciphertexts.*)
        skgen,                      (*skgen(keyseed ) : skey is the secret key generation function.*)
        pkgen,                      (*pkgen (keyseed ) : pkey is the public key generation function.*)
        enc,                            (*enc(cleartext ,pkey ) : ciphertext is the encryption function. 
                                                Internally, it generates random coins, so that it is probabilistic*)
        dec,                            (*dec(ciphertext ,skey ) : bitstringbot is the decryption function; it returns bottom 
                                                when decryption fails*)
        injbot,                         (*injbot (cleartext ) : bitstringbot is the natural injection from cleartext to bitstringbot*)
        Z,                                  (*Z (cleartext ) : cleartext is the function that returns for each cleartext a cleartext of 
                                                the same length consisting only of zeroes.*)
        Penc,                           (*Penc(t,N) is the probability of breaking the IND-CCA2 property
                                                (indistinguishable under adaptive chosen ciphertext attacks)
                                                in time t for one key and N decryption queries.*)
        Penccoll                    (*Penccoll is the probability of collision between independently generated keys.*)
).

(*
    random_split_N(input _t ,part1 _t ,...,partN _t ,tuple_t ,tuple,split )
    input _t : type of the input value
    part1 _t ,...,partN _t : types of the output parts.
    tuple_t : type of a tuple of the output parts
    tuple(part1 _t ,...,partN _t ) : tuple_t : builds a tuple from N parts.
    split (input _t ) : tuple_t splits the input into N parts and returns a tuple of these parts
        let tuple(x1,...,xN) = split (y) in...
*)
type tuple_key_bitstring_t.
type rdata [large,fixed].
type rdata_other_t [large, bounded, nonuniform].
expand random_split_2(rdata, pkey , rdata_other_t, tuple_key_bitstring_t, tuple_key_bitstring, split2).

let Challenger() =
	! qChallenger
	in(c1, ());
    (*step 1*)
	out(c2, ()).

let TD() =
	! qTD
	in(c3, ());
 
	out(c4, ()).

let TDXM() =
	! qTDXM
	in(c5, ());
	(*这里可以理解为用私钥签名*)
	out(c6, ()).

let CPU() =
	! qCPU
	in(c7, ());
	(*这里可以理解为用私钥签名*)
	out(c8, ()).

let QE() =
	! qQE
	in(c9, ());
	(*这里可以理解为用私钥签名*)
	out(c10, ()).

let VMM() =
	! qVMM
	in(c11, ());
	(*这里可以理解为用私钥签名*)
	out(c12, ()).


process
	in(start, ());
	out(c0, ());
	(
        Challenger() | 
        TD() |
        TDXM() |
        CPU() |
        VMM() |
        QE()
    )