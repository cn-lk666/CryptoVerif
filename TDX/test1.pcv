(*
    TDX protocol
    six entities: Challenger, CPU, TDXM, TD, VMM, QE.
    Steps:
    1. Challenger->TD: Attestation requirements
    2. TD generate rdata and TD->TDXM: request TD report
    3.  Assemble tdi from TDCS and compute its hash tdih
    4. TDXM->CPU: rtyp, tdi, rdata and request SEAMREPORT
    5. CPU genarate SEAMREPORT
    6. CPU->TDXM: SEAMREPORT
    7. TDXM create TDREPORT
    8. TDXM->TD: TDREPORT
    9. TD->VMM: TDREPORT and request Quote
    10. VMM->QE: TDREPORT
    11. QE check hashes
    12. QE ->CPU: report mac struct
    13. CPU verify the MAC in the report
    14. CPU->QE: Verification result
    15. QE sign to form Quote
    16. QE->VMM: Quote
    17. VMM->TD: TD: Quote
    18. TD->Challenger: Quote
*)


(*replication numbers*)
param qChallenger, qApp, qIAS.

(*
    bounded means that the type is a set of bitstrings of bounded length or perhaps ⊥. In other
        words, the type is a finite subset of bitstrings plus ⊥.
    fixed means that the type is the set of all bitstrings of a certain length n. In particular, the
        type is a finite set, so fixed implies bounded.
    large: By default, large means that the type T is large enough so that all collisions with ran-
        dom elements of T can be eliminated
*)
(*These three types are used in the macro IND_CCA2_public_key_enc and UF_CMA_det_signature*)
type skey [bounded].
type pkey [bounded].

type keypair [bounded].
type keyseed [large,fixed].
fun kp(pkey,skey):keypair [data].
type signature [bounded].
type sskey [bounded].
type spkey [bounded].
type skeypair [bounded].
type skeyseed [large,fixed].
fun skp(spkey,sskey):skeypair [data].
type macres [bounded].
(*channel name*)
channel c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, start.

(*session key*)
type key [large,fixed].
type hashoutput [large, fixed].

(* Hash *)
expand ROM_hash_large(
    key,                 (**)
    bitstring,         (*hashinput is the type of the input of the hash function.*)
    hashoutput,        (*hashoutput is the type of the output of the hash function, 
                                    must be bounded or nonuniform (typically fixed)*)
                                (*如果这里这里说了fixed，那么我们还可以用bitstring吗?还是定义一个type*)    
    hash,               (*hash (key ,hashinput ) : hashoutput is the hash function.*)
    hashoracle,  (*hashoracle is a process that allows the adversary to call the hash function*)
    qH                      (*qH is the number of queries to the hash oracle*)
).

(* MAC *)
proba Pmac.
expand SUF_CMA_det_mac(
    key,            (*mkey is the type of keys, must be bounded*)
    bitstring , (*macinput is the type of inputs of MACs*)
    macres,  (*macres is the type of MACs.*)
    mac,          (*mac(macinput ,mkey ) : macres is the MAC function.*)
    check,      (*check (macinput ,mkey ,macres ) : bool is the verification function*)
    Pmac        (*Pmac(t,N,N′,Nu′,l) is the probability of breaking the SUF-CMA property in time t for one key,
                N MAC queries, N′ verification queries modified by the transformation and Nu verification queries
                left unchanged by the transformation for messages of length at most l.*)
).


(* Signature *)
proba Psign.
proba Psigncoll.
expand UF_CMA_det_signature(
        skeyseed,
        spkey,                  (*pkey is the type of public keys, must be bounded.*)
        sskey,                  (*skey is the type of secret keys, must be bounded.*)
        bitstring,            (*signinput*)
        signature,            (*signature*)
       	sskgen,                  (*skgen(keyseed ) : skey is the secret key generation function.*)
        spkgen,                 (*pkgen (keyseed ) : pkey is the public key generation function.*)
        sign,                     (*sign (signinput ,skey ) : signature is the signature function.*)
        verify,                  (*check (signinput ,pkey ,signature) : bool is the verification function.*)
        Psign,                  (*Psign (t,N,l) is the probability of breaking the UF-CMA property 
                                        in time t, for one key, N signature queries with messages of length at most l.*)
        Psigncoll           (*Psigncoll is the probability of collision between independently generated keys.*)
).


(* Asymmetric encryption *)
proba Penc.
proba Penccoll.
expand IND_CCA2_public_key_enc(
        keyseed, 
        pkey,                       (*pkey is the type of public keys, must be bounded*)
        skey,                        (*skey is the type of secret keys, must be bounded*) 
        bitstring,                (*cleartext is the type of cleartexts.*)
        bitstring,             (*ciphertext is the type of ciphertexts.*)
        skgen,                      (*skgen(keyseed ) : skey is the secret key generation function.*)
        pkgen,                      (*pkgen (keyseed ) : pkey is the public key generation function.*)
        enc,                            (*enc(cleartext ,pkey ) : ciphertext is the encryption function. 
                                                Internally, it generates random coins, so that it is probabilistic*)
        dec,                            (*dec(ciphertext ,skey ) : bitstringbot is the decryption function; it returns bottom 
                                                when decryption fails*)
        injbot,                         (*injbot (cleartext ) : bitstringbot is the natural injection from cleartext to bitstringbot*)
        Z,                                  (*Z (cleartext ) : cleartext is the function that returns for each cleartext a cleartext of 
                                                the same length consisting only of zeroes.*)
        Penc,                           (*Penc(t,N) is the probability of breaking the IND-CCA2 property
                                                (indistinguishable under adaptive chosen ciphertext attacks)
                                                in time t for one key and N decryption queries.*)
        Penccoll                    (*Penccoll is the probability of collision between independently generated keys.*)
).

(*Symmetric encryption*)
proba sym_Penc.
expand IND_CPA_sym_enc(
        key, 
        bitstring,      (*cleartext is the type of cleartexts.*)
        bitstring,       (*ciphertext is the type of ciphertexts.*)
        sym_enc,       (*enc(cleartext ,key ) : ciphertext is the encryption function. *)
        sym_dec,       (*dec(ciphertext ,key ) : bitstringbot is the decryption function; 
                                      it returns bottom when decryption fails.*)
        sym_injbot ,            (*injbot (cleartext ) : bitstringbot is the natural injection from cleartext to bitstringbot.*)
        sym_Z,                      (*Z (cleartext ) : cleartext is the function that 
                                    returns for each cleartext a cleartext of the same length consisting only of zeroes.*)
        sym_Penc      (*Penc(t,N,l) is the probability of breaking the IND-CPA property in time t 
                                      for one key and N encryption queries with cleartexts of length at most l.*)
).


letfun kgen() =  k <-R keyseed;  kp (pkgen(k) ,skgen(k) ).
letfun kgen_s() =  ks <-R skeyseed;  skp (spkgen(ks) ,sskgen(ks) ).


type rtyp_t[bounded].
type res_t[bounded,nonuniform].
type csvn_t[fixed].
type user_data_t [bounded, nonuniform].
type tcbi_t[fixed].
type tdi_t[fixed].

type rdata_t[bounded].
type rms_without_mac_t[bounded].
type rms_t[bounded].
type smr_t[bounded].
type smr_without_mac_t[bounded].
type tdr_t[bounded].
type tdr_without_mac_t[bounded].
type quote_t[bounded].

type hostname[bounded].
set diffConstants = false.
const hostname_TD:hostname.
const hostname_TDXM:hostname.
const hostname_CPU:hostname.

fun get_rtyp():rtyp_t.
fun get_tdi():tdi_t.



fun rdata_f(pkey, user_data_t):rdata_t[data].
fun rms_without_mac_f(rtyp_t, res_t, csvn_t, hashoutput, hashoutput, rdata_t, res_t): rms_without_mac_t[data].
fun rms_f(rtyp_t, res_t, csvn_t, hashoutput, hashoutput, rdata_t, res_t, macres):rms_t[data].
fun smr_f(rms_t, tcbi_t):smr_t[data].
fun tdr_f(smr_t, res_t, tdi_t):tdr_t[data].
fun quote_f(tdr_t, signature):quote_t[data].
fun tdi_t2bitstring(tdi_t): bitstring [data].
fun tcbi_t2bitstring(tcbi_t):bitstring[data].

table Ch_IAS(bitstring).
table IAS_Ch(bitstring, bool, pkey).

table TD_TDXM_2(hostname, hostname, rdata_t).
implementation table TD_TDXM_2="TD_TDXM_2".
table TDXM_CPU_4(hostname, hostname, rtyp_t, hashoutput, rdata_t).
implementation table TDXM_CPU_4="TDXM_CPU_4".

implementation
    type skeyseed=64;
    type keyseed=64;
    type key = 128;
    type user_data_t=1024;
    type macres = "string";
    fun tdi_t2bitstring="tdi_t2bitstring" [inverse = "bitstring2tdi_t"];
    fun tcbi_t2bitstring="tdi_t2bitstring" [inverse = "bitstring2tcbi_t"]; 
    type pkey="pkey" [serial = "pkey_to","pkey_from"];
    type skey="skey" [serial = "skey_to","skey_from"];                  
    fun kgen = "(pk_kgen 1024)";
    fun kgen_s = "(pk_kgen 1024)";
    fun kp="id" [inverse="id"];
    fun skp="id" [inverse="id"];
    fun hostname_TD="get_TD";
    fun hostname_TDXM="get_TDXM";
    fun hostname_CPU="get_CPU";
    fun hash = "Ssh_crypto.hash";
    fun get_rtyp="get_rtyp";
    fun get_tdi="get_tdi";
    fun rdata_f="rdata_f"[inverse = "inv_rdata_f"];
    type signature="string";
    type hashoutput=160;
    type hostname="string" [serial = "id", "id"];
    type rdata_t="string" [serial = "id", "id"];
    type rtyp_t="string" [serial = "id", "id"];
    type spkey="pkey" [serial = "pkey_to","pkey_from"];
    type sskey="skey" [serial = "skey_to","skey_from"].




let TD(pk_TD:pkey, sk_TD:skey)=

    TDX_TD{
        in(c4, ());
        new rdata_other:user_data_t;
        let rdata_TD=rdata_f(pk_TD, rdata_other) in
        insert TD_TDXM_2(hostname_TD, hostname_TDXM, rdata_TD);
        out(c5, ())
    }.

let TDXM(hk_TDXM:key)=
    TDX_TDXM{
        in(c6, ());
        get TD_TDXM_2(x, y, rdata_TDXM) suchthat x=hostname_TD && y=hostname_TDXM in
        let tdi=get_tdi() in
        let rtyp=get_rtyp() in
        let tdih=hash(hk_TDXM, tdi_t2bitstring(tdi)) in
        insert TDXM_CPU_4(hostname_TDXM, hostname_CPU, rtyp, tdih, rdata_TDXM);
        out(c7, ())
    }.

let CPU(hk_CPU:key, mkey_CPU:key)=
    TDX_CPU{
        in(c8, ());
        out(c9, ())
    }.

let VMM()=
    TDX_VMM{
        in(c10, ());
        out(c11, ())
    }.

let QE(hk_QE:key, ssk:sskey, pk: pkey)=
    TDX_QE{
        in(c12, ());
        out(c13, ())
    }.


let Challenger()=
    in(c2, ());

    out(c3, ()).


let Application(ssk:sskey, pk:pkey) =
TDX_keygen_App[pk3>pk3, sk3>sk3, hk>hk, mkey>mkey]{
    in(c21, ());
    let kp (pk3:pkey,sk3:skey) = kgen () in
    new hk:key;(*key for hash*)
    new mkey:key;(*key for mac*)
    out(c22, ())
};
(
    (hashoracle(hk) ) |
    (!i<=qApp TD(pk3, sk3) ) |
    (!i<=qApp TDXM(hk) ) |    
    (!i<=qApp CPU(hk, mkey) ) |
    (!i<=qApp VMM() ) |
    (!i<=qApp QE(hk, ssk, pk) )   
).

let IAS(spk:spkey, sk:skey)=
    in(c26, ());
    out(c27, ()).



process
    TDX_Keygen [spk1 > spk_IAS, ssk1 > ssk_QE, pk2 > pk_QE, sk2 > sk_IAS ]{
        in(start, ());
        let skp (spk1:spkey,ssk1:sskey) = kgen_s () in
        let kp (pk2:pkey,sk2:skey) = kgen () in
        out (c1, ())
    };
	(
        (!i<= qChallenger Challenger()) | 
        (Application(ssk1, pk2)) |
        (!i<= qIAS IAS(spk1, sk2))
    )